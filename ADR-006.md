# Architecture Decision Record (ADR)

## FastAPI Microservices + Docker + NGINX Reverse Proxy + Production Hardening

------------------------------------------------------------------------

# 1. Context

This project implements a production-oriented backend architecture
using:

-   FastAPI microservices
-   Docker containerization
-   NGINX as Reverse Proxy & API Gateway
-   Load balancing across service replicas
-   Performance tuning and rate limiting
-   Basic caching strategies
-   Health checks
-   Production hardening practices

The goal is to move from a development-ready system to a
**production-grade, scalable, and resilient architecture**.

------------------------------------------------------------------------

# 2. Architecture Overview

## Core Services

-   Auth Service (auth_v1, auth_v2)
-   Notes Service (notes_v1, notes_v2)
-   Assets Service
-   PostgreSQL
-   MongoDB
-   NGINX Gateway

NGINX acts as:

-   Reverse proxy
-   Load balancer
-   Rate limiter
-   Compression handler
-   Cache layer

------------------------------------------------------------------------

# 3. Decision Summary

## 3.1 Docker-Based Deployment

### Decision

All services run as independent containers orchestrated via
docker-compose.

### Rationale

-   Environment consistency
-   Isolation between services
-   Easy scaling via replicas
-   Production-like local environment

------------------------------------------------------------------------

## 3.2 NGINX Reverse Proxy

### Decision

Use NGINX as API gateway.

### Responsibilities

-   Routing requests to upstream services
-   Load balancing
-   Rate limiting
-   Timeout handling
-   Compression (gzip)
-   Basic caching

### Benefits

-   Decouples clients from internal services
-   Centralized traffic control
-   Performance optimization

------------------------------------------------------------------------

## 3.3 Upstream Load Balancing

### Decision

Use upstream blocks:

-   auth_service
-   notes_service
-   assets_service

Example strategy:

-   least_conn balancing
-   fail_timeout handling
-   max_fails configuration

### Benefits

-   Horizontal scaling
-   Failover resilience
-   Reduced latency under load

------------------------------------------------------------------------

## 3.4 Performance Optimization

### Implemented

-   sendfile on
-   tcp_nopush on
-   proxy buffering
-   gzip compression
-   multiple workers in backend app
-   k6 load testing validation

### Goals

-   Reduce latency
-   Improve throughput
-   Validate scalability

------------------------------------------------------------------------

## 3.5 Rate Limiting

### Decision

Apply rate limiting globally using:

limit_req_zone based on client IP.

### Purpose

-   Protect backend from abuse
-   Avoid overload during spikes

------------------------------------------------------------------------

## 3.6 Basic Caching

### Decision

Enable proxy_cache for selected routes (e.g., notes).

### Rationale

-   Reduce backend load
-   Faster responses for repeated requests

------------------------------------------------------------------------

## 3.7 Health Checks

### Decision

Expose /health endpoint in each service.

### Usage

-   Container health validation
-   Future orchestration compatibility
-   Automatic failure detection

------------------------------------------------------------------------

## 3.8 Security Hardening

### Implemented Headers

-   X-Frame-Options
-   X-Content-Type-Options
-   X-XSS-Protection

### Benefits

-   Improved browser-side security
-   Basic mitigation against common attacks

------------------------------------------------------------------------

## 3.9 Observability Preparation

### Logging Strategy

Custom log_format capturing:

-   client IP
-   request
-   status code
-   request time

Purpose:

-   Performance analysis
-   Debugging
-   Monitoring readiness

------------------------------------------------------------------------

## 3.10 Production Application Server

### Decision

Use gunicorn with uvicorn workers instead of standalone uvicorn.

Example:

gunicorn main:app -k uvicorn.workers.UvicornWorker -w 4

### Benefits

-   Better concurrency
-   Improved stability under load
-   Production-grade worker management

------------------------------------------------------------------------

## 3.11 Zero Downtime Deployment (Preparation)

Architecture designed to support:

-   Blue/Green deployments
-   Rolling updates
-   NGINX upstream switching without downtime

------------------------------------------------------------------------

# 4. Alternatives Considered

-   Direct service exposure without NGINX (Rejected: lacks central
    control)
-   Single instance services (Rejected: no redundancy)
-   No caching (Rejected: higher backend load)

------------------------------------------------------------------------

# 5. Consequences

## Positive

-   Scalable architecture
-   Better fault tolerance
-   Performance improvements
-   Production-aligned structure

## Tradeoffs

-   Increased complexity
-   Requires monitoring setup
-   More configuration management

------------------------------------------------------------------------

# 6. Future Improvements

-   HTTPS termination with TLS
-   Prometheus metrics + Grafana dashboards
-   Structured JSON logging
-   Distributed tracing (OpenTelemetry)
-   Autoscaling orchestration (Kubernetes)

------------------------------------------------------------------------

# 7. Final Notes

This ADR documents the evolution from a simple backend deployment toward
a production-ready architecture using industry-standard practices.
